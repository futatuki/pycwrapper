#!/usr/bin/env python
# $yfId$
import os.path 

numptr_basename = 'numptr'
cobj_import_text="from .cobj cimport CObjPtr\n"
bcls_text="CObjPtr"
ncls_seeds = [
    {'ctype' : 'int',                'clsname' : 'CIntPtr',     'defval' : 0},
    {'ctype' : 'unsigned int',       'clsname' : 'CUIntPtr',    'defval' : 0},
    {'ctype' : 'short',              'clsname' : 'CShortPtr',   'defval' : 0},
    {'ctype' : 'unsigned short',     'clsname' : 'CUShortPtr',  'defval' : 0},
    {'ctype' : 'long',               'clsname' : 'CLongPtr',    'defval' : 0},
    {'ctype' : 'unsigned long',      'clsname' : 'CULongPtr',   'defval' : 0},
    {'ctype' : 'long long',          'clsname' : 'CLLongPtr',   'defval' : 0},
    {'ctype' : 'unsigned long long', 'clsname' : 'CULLongPtr',  'defval' : 0},
    {'ctype' : 'float',              'clsname' : 'CFloatPtr',   'defval' : 0},
    {'ctype' : 'double',             'clsname' : 'CDoublePtr',  'defval' : 0},
    {'ctype' : 'long double',        'clsname' : 'CLDoublePtr', 'defval' : 0}]


def fileheader(fname, import_text):
    return """# %s, generated by
#   $yfId$
from __future__ import absolute_import
%s
""" % (fname, import_text)

def numptrclsdef(**kw):
    return """
def gen_%(clsname)s(etypename, base): 
    def __new__(cls, vals=None, nelms=0, is_const=False, **m):
        cdef CObjPtr ref
        cdef object c_base
        ref = base.__new__(cls, vals, nelms, is_const, **m)
        c_base = ('const ' if is_const else '') + '%(ctype)s'
        ref._c_base_type = c_base
        ref._c_esize = sizeof(%(ctype)s)
        ref._mddict = { 'p_' : %(defval)s }
        return ref
    def p_getter(CObjPtr self):
        assert self._c_ptr is not NULL
        return (<%(ctype)s *>(self._c_ptr))[0]
    def p_setter(CObjPtr self, val):
        assert self._c_ptr is not NULL
        if self._is_const and self._is_init:
            raise TypeError('Pointer points const value. Cannot alter')
        (<%(ctype)s*>(self._c_ptr))[0] = val
    def p_deleter(CObjPtr self):
        assert self._c_ptr is not NULL
        (<%(ctype)s*>(self._c_ptr))[0] = %(defval)s
    # function body
    if not issubclass(base, CObjPtr):
        raise TypeError('base must be CObjPtr or its derivatives')
    attrdict = {'__new__'  : staticmethod(__new__),
                'p_'       : property(p_getter,p_setter,p_deleter)}
    return type(etypename, (base,), attrdict.copy())
""" % kw

def write_cython_src(prefix, basename,
        import_text=cobj_import_text, clsdef=ncls_seeds, bcls_name=bcls_text):

    if not basename:
        raise ValueError('basename is needed')
    if prefix:
        pyxfname = os.path.join(prefix, basename + '.pyx')
    else:
        pyxfname = basename + '.pyx'
    pyxfile = open(pyxfname, 'w')
    # write header
    pyxfile.write(fileheader(pyxfname,import_text))
    for s in clsdef:
        pyxfile.write(numptrclsdef(**s))
    pyxfile.write("\n")
    for s in clsdef:
        pyxfile.write(
                "%(clsname)s = gen_%(clsname)s('%(clsname)s', %(bcls_name)s)\n"
                % {'clsname': s['clsname'], 'bcls_name': bcls_name})
    pyxfile.close()

def main():
    write_cython_src(prefix=None, basename=numptr_basename,
        import_text=cobj_import_text, clsdef=ncls_seeds, bcls_name=bcls_text)

if __name__ == "__main__":
    main()
